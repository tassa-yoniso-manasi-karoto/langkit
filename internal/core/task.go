package core

import (
	"fmt"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"time"

	"github.com/gookit/color"
	"github.com/k0kubun/pp"
	"github.com/rs/zerolog"
	"github.com/spf13/cobra"

	"github.com/tassa-yoniso-manasi-karoto/langkit/internal/config"
	"github.com/tassa-yoniso-manasi-karoto/langkit/internal/executils"
	"github.com/tassa-yoniso-manasi-karoto/langkit/internal/pkg/media"
	"github.com/tassa-yoniso-manasi-karoto/langkit/internal/pkg/subs"
	"github.com/tassa-yoniso-manasi-karoto/langkit/internal/pkg/voice"
	"github.com/tassa-yoniso-manasi-karoto/langkit/pkg/metadata"
)

// DryRunConfig contains configuration for dry run testing mode
type DryRunConfig struct {
	Enabled         bool               // Whether dry run mode is active
	DelayMs         int                // Delay between tasks in milliseconds
	ErrorPoints     map[int]string     // Map of task index -> error type ("abort_task" or "abort_all")
	NextErrorIndex  int                // Index for manual error injection (-1 means no injection)
	NextErrorType   string             // Type of next manual error
	ProcessedCount  int                // Number of tasks processed so far
}

func init() {
	zerolog.SetGlobalLevel(zerolog.TraceLevel)
}

type Mode int

const (
	Subs2Cards = iota
	Subs2Dubs
	Enhance
	Translit
	Condense
)

func (m Mode) String() string{
	return []string{"Subs2Cards", "Subs2Dubs", "Enhance", "Translit", "Condense"}[m]
}

type Meta struct {
	FFmpeg string
	MediaInfo MediaInfo
	WorkersMax int
}


// MediaOutputType represents the type of media output file
type MediaOutputType string

const (
	// Output types for merging
	OutputVideo       MediaOutputType = "video"
	OutputAudio       MediaOutputType = "audio"
	OutputSubtitle    MediaOutputType = "subtitle"
	OutputDubtitle    MediaOutputType = "dubtitle"
	OutputRomanized   MediaOutputType = "romanized"
	OutputTokenized   MediaOutputType = "tokenized"
	OutputTranslit    MediaOutputType = "translit"
	OutputEnhanced    MediaOutputType = "enhanced"
)

// MediaOutputFile stores information about a file to be potentially included in the merged output
type MediaOutputFile struct {
	Path        string          // Full path to the file
	Type        MediaOutputType // Type of the file (video, audio, subtitle, etc.)
	Lang        Lang            // Language of the file content
	IsGenerated bool            // Whether this file was generated by this processing run
	Feature     string          // Feature that generated this file (e.g., "dubtitles", "voiceEnhancing")
	Priority    int             // Priority for merging (higher priority files of the same type replace lower ones)
}

type Task struct {
	Handler              MessageHandler
	Meta                 Meta
	Mode                 Mode
	
	// // Injected services for testability
	// LanguageDetector     LanguageDetector
	// MediaInfoProvider    MediaInfoProvider
	// TrackSelector        TrackSelector
	// PathService          PathService
	
	// Language settings
	OriginalLang         string // FIXME what for?
	Langs                []string
	RefLangs             []Lang
	Targ                 Lang
	Native               Lang
	
	// File paths
	// mediaSourceFile is the path of the actual media provided or any media found while routing()
	MediaSourceFile      string
	TargSubFile          string
	NativeSubFile        string
	// mediaprefix is the base string for building AVIF / OPUS to which timecodes of a subtitle line will be added.
	MediaPrefix          string // base string for building AVIF/OPUS
	
	// Subtitles
	NativeSubs           *subs.Subtitles
	TargSubs             *subs.Subtitles
	
	// Processing options
	IsBulkProcess        bool
	DubsOnly             bool
	IsCCorDubs           bool
	
	// Common options
	FieldSep             string // defaults to "\t"
	OutputFileExtension  string // defaults to ".tsv" for "\t" and ".csv" otherwise
	Offset               time.Duration
	MaxAPIRetries        int
	WantCondensedAudio   bool
	CondensedAudioFmt    string
	WantEnhancedTrack    bool // Used when Condense mode should also create an enhanced track
	
	// Summary options for condensed audio
	WantSummary         bool   // Whether to generate a summary for condensed audio
	SummaryProvider     string // LLM provider to use for summarization (e.g., "openai", "google")
	SummaryModel        string // Model to use within the provider (e.g., "gpt-4o", "models/gemini-1.5-pro-latest")
	SummaryOutputLang   string // Desired language for the summary output (e.g., "en", "fr", user's NativeLang)
	SummaryMaxLength    int    // Approximate max length in words for the summary
	SummaryTemperature  float64// Temperature for summary generation (-1 for default)
	SummaryCustomPrompt string // User-provided custom prompt for summarization
	UseSymbolicEmphasis bool   // Whether to use UTF-8 mathematical symbols for emphasis instead of markdown/HTML
	
	// Audio track options
	TargetChan           int // TODO rename TargetChanNum
	UseAudiotrack        int
	
	// Voice enhancement options
	SeparationLib        string
	TimeoutSep           int
	VoiceBoost           float64
	OriginalBoost        float64
	Limiter              float64
	MergingFormat        string
	
	// STT options
	STT                  string
	TimeoutSTT           int
	TimeoutDL            int  // timeout for download operations
	WantDubs             bool // controls whether dubtitle file should be made too when using STT for subs2cards
	InitialPrompt        string
	
	// File handling options
	IntermediaryFileMode config.IntermediaryFileMode // How to handle intermediary files
	DeleteResumptionFiles bool                       // Whether to delete TSV/CSV resumption files
	SkipWAVExtraction    bool                        // Skip individual WAV extraction if concatenated WAV exists
	
	// Subtitle processing options
	WantTranslit               bool // TODO use len(TranslitTypes) > 0 instead
	TranslitTypes              []TranslitType
	RomanizationStyle          string
	KanjiThreshold             int
	TokenizeSelectiveTranslit  bool
	BrowserAccessURL           string
	DockerRecreate             bool
	
	// Output merging options
	MergeOutputFiles     bool                // Whether to merge all output files
	OutputFiles          []MediaOutputFile   // Files to be included in merged output
	
	// Intermediary file management
	fileManager          *IntermediaryFileManager
	
	// Dry run testing fields
	IsDryRun             bool           // Whether this is a dry run test
	DryRunConfig         *DryRunConfig  // Configuration for dry run testing
}

func NewTask(handler MessageHandler) (tsk *Task) {
	tsk = &Task{
		Handler: handler,
		Meta: Meta { WorkersMax: runtime.NumCPU()-2 },
		
		// Default task settings
		UseAudiotrack: -1,
		TargetChan: 2,
		VoiceBoost: 13,
		OriginalBoost: -9,
		Limiter:  0.9,
		MaxAPIRetries: 10,
		// 2100s = 35 minutes: @150 KB/s → max 315MB uploaded before timeout,
		// should be way enough for any movie/serie audio on any network since we encode it in OPUS
		TimeoutSep: 2100,  
		TimeoutSTT: 90,   // 90 seconds for each subtitle audio segment
		TimeoutDL: 600,   // 10 minutes for downloading files
		// the actual control over STT activation remains STT string being != "",
		// by default assume a subtitle file is wanted and therefore
		// let that value be overwritten as needed (currently only by CLI).
		WantDubs: true,
		KanjiThreshold: -1,
		
		// Default file handling settings
		IntermediaryFileMode: config.KeepIntermediaryFiles,
		DeleteResumptionFiles: false,
		
		// Default output merging settings
		MergeOutputFiles: false,
		MergingFormat: "mp4",
		OutputFiles: []MediaOutputFile{},
	}
	
	if tsk.FieldSep == "" {
		tsk.FieldSep = "\t"
	}
	if tsk.OutputFileExtension == "" {
		switch tsk.FieldSep {
		case "\t":
			tsk.OutputFileExtension = ".tsv"
		default:
			tsk.OutputFileExtension = ".csv"
		}
	}

	// Find and set binary paths using the unified finder
	if ffmpegPath, err := executils.FindBinary("ffmpeg"); err == nil {
		media.FFmpegPath = ffmpegPath
		metadata.FFmpegPath = ffmpegPath
		tsk.Handler.ZeroLog().Debug().Str("path", ffmpegPath).Msg("Found ffmpeg for CLI task")
	} else {
		tsk.Handler.ZeroLog().Warn().Err(err).Msg("ffmpeg not found for CLI task")
	}

	if mediainfoPath, err := executils.FindBinary("mediainfo"); err == nil {
		MediainfoPath = mediainfoPath
		tsk.Handler.ZeroLog().Debug().Str("path", mediainfoPath).Msg("Found mediainfo for CLI task")
	} else {
		tsk.Handler.ZeroLog().Warn().Err(err).Msg("mediainfo not found for CLI task")
	}

	if settings, err := config.LoadSettings(); err == nil {
		tsk.ApplyConfig(settings)
	} else {
		tsk.Handler.ZeroLog().Error().Err(err).Msg("Failed to load settings")
	}

	return tsk
}

func (tsk *Task) ApplyConfig(settings config.Settings) {
	if settings.MaxAPIRetries > 0 {
		tsk.MaxAPIRetries = settings.MaxAPIRetries
	}
	
	if settings.MaxWorkers > 0 {
		tsk.Meta.WorkersMax = settings.MaxWorkers
	}
	
	// Apply timeout settings
	if settings.TimeoutSep > 0 {
		tsk.TimeoutSep = settings.TimeoutSep
	}
	
	if settings.TimeoutSTT > 0 {
		tsk.TimeoutSTT = settings.TimeoutSTT
	}
	
	if settings.TimeoutDL > 0 {
		tsk.TimeoutDL = settings.TimeoutDL
	}
	
	// Apply intermediary file mode if set
	if settings.IntermediaryFileMode != "" {
		tsk.IntermediaryFileMode = settings.IntermediaryFileMode
	}
	
	// Apply delete resumption files setting
	tsk.DeleteResumptionFiles = settings.DeleteResumptionFiles
	
	// FIXME CLI wasn't designed with a default language in config in mind → unknown behavior down the line
	if settings.TargetLanguage != "" {
		tsk.Langs = []string{settings.TargetLanguage}
		if settings.NativeLanguages != "" {
			tsk.Langs = append(tsk.Langs, TagsStr2TagsArr(settings.NativeLanguages)...)
		}
	}
}

func (tsk *Task) ApplyCLIFlags(cmd *cobra.Command) *ProcessingError {
	// override config settings if specified
	tsk.applyCLIFlags(cmd)
	
	if procErr := tsk.PrepareLangs(); procErr != nil {
		return procErr
	}
	tsk.Handler.ZeroLog().Trace().Strs("langs", tsk.Langs).Msg("PrepareLangs done")
	
	// Normalize STT model name if one is specified
	if tsk.STT != "" {
		// Check if the model exists
		provider, err := voice.GetSpeechToTextProvider(tsk.STT)
		if err != nil {
			tsk.Handler.ZeroLog().Warn().
				Str("model", tsk.STT).
				Msg("Unknown STT model specified")
		} else {
			// Special case for legacy naming compatibility
			providerName := provider.GetName()
			if providerName == "incredibly-fast-whisper" {
				tsk.STT = "insanely-fast-whisper" // Maintain backward compatibility
			} else {
				// Use the normalized name
				tsk.STT = providerName
			}
			
			tsk.Handler.ZeroLog().Trace().
				Str("normalizedSTT", tsk.STT).
				Msg("Normalized STT model name")
		}
	}
	
	// Handle audio separation library aliases
	switch tsk.SeparationLib {
	case "de":
		tsk.SeparationLib = "demucs"
	case "ft":
		tsk.SeparationLib = "demucs_ft"
	case "sp":
		tsk.SeparationLib = "spleeter"
	case "11", "el":
		tsk.SeparationLib = "elevenlabs"
	}
	
	return nil
}


// applyCLIFlags applies settings from command line flags
func (tsk *Task) applyCLIFlags(cmd *cobra.Command) {
	strFlags := map[string]*string{
		"sep":                &tsk.SeparationLib,
		"stt":                &tsk.STT,
		"browser-access-url": &tsk.BrowserAccessURL,
		"merge-format":       &tsk.MergingFormat,
	}
	
	// Special handling for intermediary-files flag (needs conversion to IntermediaryFileMode)
	if cmd.Flags().Changed("intermediary-files") {
		if val, err := cmd.Flags().GetString("intermediary-files"); err == nil {
			tsk.IntermediaryFileMode = config.IntermediaryFileMode(val)
		}
	}
	
	intFlags := map[string]*int{
		"chan":    &tsk.TargetChan,
		"workers": &tsk.Meta.WorkersMax,
		"sep-to":  &tsk.TimeoutSep,
		"stt-to":  &tsk.TimeoutSTT,
		"dl-to":   &tsk.TimeoutDL,
		"w":       &media.MaxWidth,
		"h":       &media.MaxHeight,
	}
	
	boolFlags := map[string]*bool{
		"stt-dub":                &tsk.WantDubs,
		"translit":               &tsk.WantTranslit,
		"merge":                  &tsk.MergeOutputFiles,
		"enhance":                &tsk.WantEnhancedTrack,
		"delete-resumption-files": &tsk.DeleteResumptionFiles,
	}
	
	// Special case for "offset" which needs conversion to time.Duration
	if cmd.Flags().Changed("offset") {
		if val, err := cmd.Flags().GetInt("offset"); err == nil {
			tsk.Offset = time.Duration(val) * time.Millisecond
		}
	}
	
	// Special case for "a" (audiotrack) which needs adjustment
	if cmd.Flags().Changed("a") {
		if val, err := cmd.Flags().GetInt("a"); err == nil {
			tsk.UseAudiotrack = val - 1
		}
	}
	
	// Special case for "langs" which is a string slice
	if cmd.Flags().Changed("langs") {
		if val, err := cmd.Flags().GetStringSlice("langs"); err == nil {
			tsk.Langs = val
		}
	}
	
	// STRING
	for name, dest := range strFlags {
		if cmd.Flags().Changed(name) {
			if val, err := cmd.Flags().GetString(name); err == nil {
				*dest = val
			}
		}
	}
	
	// INT
	for name, dest := range intFlags {
		if cmd.Flags().Changed(name) {
			if val, err := cmd.Flags().GetInt(name); err == nil {
				*dest = val
			}
		}
	}
	
	// BOOL
	for name, dest := range boolFlags {
		if cmd.Flags().Changed(name) {
			if val, err := cmd.Flags().GetBool(name); err == nil {
				*dest = val
			}
		}
	}
	
	// Binary paths
	for _, name := range []string{"ffmpeg", "mediainfo"} {
		if cmd.Flags().Changed(name) {
			path, _ := cmd.Flags().GetString(name)
			tsk.Handler.ZeroLog().Debug().Msgf("using flag-provided binary for %s: %s", name, path)
			
			if runtime.GOOS == "windows" {
				name += ".exe"
			}
			
			switch name {
			case "ffmpeg", "ffmpeg.exe":
				media.FFmpegPath = path
			case "mediainfo", "mediainfo.exe":
				MediainfoPath = path
			}
		}
	}
}


// DebugVals returns a string representation of a sanitized copy of the Task for crash reporting.
// It makes a shallow copy of the Task and sets all interface fields to nil before pretty printing.
// This prevents memory leaks that can occur when large interface implementations or circular 
// references are included in the pretty-printed output. The returned string contains all primitive
// values and configuration settings while excluding potentially problematic service references.
func (tsk *Task) DebugVals() string {
	cp := *tsk // shallow copy
	
	cp.Handler = nil
	
	cp.NativeSubs = &subs.Subtitles{}
	cp.TargSubs = &subs.Subtitles{}
	
	// Create a sanitized copy of the file manager to avoid exposing the handler context
	if cp.fileManager != nil {
		sanitizedFileManager := &IntermediaryFileManager{
			mode:      cp.fileManager.mode,
			deleteTSV: cp.fileManager.deleteTSV,
			handler:   nil, // Remove the handler with its massive context
			// Copy the file arrays to preserve diagnostic info
			audioFiles: append([]string(nil), cp.fileManager.audioFiles...),
			imageFiles: append([]string(nil), cp.fileManager.imageFiles...),
			wavFiles:   append([]string(nil), cp.fileManager.wavFiles...),
			otherFiles: append([]string(nil), cp.fileManager.otherFiles...),
		}
		cp.fileManager = sanitizedFileManager
	}
	
	return pp.Sprintln(cp)
}


// CheckConcatenatedWAV checks if a concatenated WAV file already exists in temp
// and sets SkipWAVExtraction accordingly. This optimization allows skipping
// individual WAV segment extraction when re-processing with different output formats.
func (tsk *Task) CheckConcatenatedWAV() {
	// Only check if we're in a mode that will create condensed audio
	if tsk.Mode == Condense || tsk.WantCondensedAudio {
		tempBaseName := path.Base(tsk.MediaPrefix) + ".concatenated.wav"
		tempWavFile := filepath.Join(os.TempDir(), tempBaseName)
		
		if _, err := os.Stat(tempWavFile); err == nil {
			tsk.SkipWAVExtraction = true
			tsk.Handler.ZeroLog().Info().
				Str("tempWavFile", tempWavFile).
				Msg("Found existing concatenated WAV file, will skip individual WAV extraction")
		} else {
			tsk.Handler.ZeroLog().Debug().
				Str("tempWavFile", tempWavFile).
				Msg("No existing concatenated WAV file found, will extract individual segments")
		}
	}
}

func placeholder2345634567() {
	fmt.Print("")
	color.Redln(" 𝒻*** 𝓎ℴ𝓊 𝒸ℴ𝓂𝓅𝒾𝓁ℯ𝓇")
	pp.Println("𝓯*** 𝔂𝓸𝓾 𝓬𝓸𝓶𝓹𝓲𝓵𝓮𝓻")
}
