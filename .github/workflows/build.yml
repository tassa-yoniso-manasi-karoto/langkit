name: Build langkit

on:
  push:
    branches: [ main, master ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main, master ]

env:
  NODE_OPTIONS: "--max-old-space-size=4096"
  GO_VERSION: '1.23'  # Required by dAppServer/wails-build-action
  NODE_VERSION: '18'
  WAILS_VERSION: 'v2.9.0'  # v2.10+ is problematic per wails-build-action docs

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        build:
          - name: langkit
            platform: linux/amd64
            platform_sanitized: linux-amd64
            os: ubuntu-22.04  # Pinned for stability with Wails v2.9.0
          - name: langkit
            platform: windows/amd64
            platform_sanitized: windows-amd64
            os: windows-latest
          - name: langkit
            platform: darwin/universal
            platform_sanitized: darwin-universal
            os: macos-latest
    
    runs-on: ${{ matrix.build.os }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive
          
      # Setup build environment
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown
          
      # Install system dependencies
      - name: Install build dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          
      # Caching
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-${{ runner.arch }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-go-
            
      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: internal/gui/frontend/src/wasm -> target
          
      - name: Cache Node modules
        uses: actions/cache@v4
        with:
          path: internal/gui/frontend/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('internal/gui/frontend/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
            
      - name: Cache wasm-pack binaries
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/.wasm-pack
            ~/Library/Caches/.wasm-pack
            ~/AppData/Local/wasm-pack/cache
          key: ${{ runner.os }}-wasm-pack-bins
          restore-keys: |
            ${{ runner.os }}-wasm-pack-bins
            
      # Install wasm-pack - pinned version for macOS to avoid wasm-opt issues
      - name: Install wasm-pack (macOS)
        if: runner.os == 'macOS'
        run: |
          echo "Installing wasm-pack v0.10.3 for macOS (known to work with our WASM)"
          curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh -s -- --version 0.10.3
          
      - name: Install wasm-pack (Linux/Windows)
        if: runner.os != 'macOS'
        uses: jetli/wasm-pack-action@v0.4.0
        
      # Build WASM components with your custom inlining process
      - name: Build WebAssembly components
        working-directory: internal/gui/frontend
        shell: bash
        run: |
          npm install
          npm run build:wasm
          
      # Diagnostic step for macOS
      - name: macOS Build Diagnostics
        if: runner.os == 'macOS'
        shell: bash
        run: |
          echo "=== macOS Build Environment ==="
          echo "Runner architecture: ${{ runner.arch }}"
          echo "Go version: $(go version)"
          echo "GOARCH: $(go env GOARCH)"
          echo "GOOS: $(go env GOOS)"
          echo "CGO_ENABLED: $(go env CGO_ENABLED)"
          uname -a
          
      # Prepare version information
      - name: Prepare version info
        id: version
        shell: bash
        run: |
          # Get version from tag or use 'dev'
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            VERSION="${{ github.ref_name }}"
            # Remove 'v' prefix if present
            VERSION="${VERSION#v}"
          else
            VERSION="dev"
          fi
          
          # Get commit SHA (short version)
          COMMIT="${{ github.sha }}"
          COMMIT="${COMMIT:0:7}"
          
          # Get branch name
          if [[ "${{ github.ref_type }}" == "branch" ]]; then
            BRANCH="${{ github.ref_name }}"
          else
            BRANCH="unknown"
          fi
          
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "COMMIT=$COMMIT" >> $GITHUB_OUTPUT
          echo "BRANCH=$BRANCH" >> $GITHUB_OUTPUT
          
          echo "Building with version info:"
          echo "  Version: $VERSION"
          echo "  Commit: $COMMIT"
          echo "  Branch: $BRANCH"
          
      # Build CLI binary
      - name: Build CLI
        shell: bash
        run: |
          # Prepare ldflags with version information
          LDFLAGS="-s -w"
          LDFLAGS="$LDFLAGS -X github.com/tassa-yoniso-manasi-karoto/langkit/internal/version.Version=${{ steps.version.outputs.VERSION }}"
          LDFLAGS="$LDFLAGS -X github.com/tassa-yoniso-manasi-karoto/langkit/internal/version.Commit=${{ steps.version.outputs.COMMIT }}"
          LDFLAGS="$LDFLAGS -X github.com/tassa-yoniso-manasi-karoto/langkit/internal/version.Branch=${{ steps.version.outputs.BRANCH }}"
          
          # Let Go detect the architecture on macOS (could be arm64 or amd64)
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            echo "Building CLI for macOS (auto-detecting architecture)"
            # Ensure CGO is enabled for macOS
            export CGO_ENABLED=1
            go build -ldflags="$LDFLAGS" -o langkit-cli ./cmd/cli
          else
            # Explicitly set for Windows and Linux
            export GOOS=${{ runner.os == 'Windows' && 'windows' || 'linux' }}
            export GOARCH=amd64
            echo "Building CLI for GOOS=$GOOS GOARCH=$GOARCH"
            go build -ldflags="$LDFLAGS" -o langkit-cli${{ runner.os == 'Windows' && '.exe' || '' }} ./cmd/cli
          fi
          
      # Build GUI with Wails using the action
      - name: Build GUI with Wails
        uses: dAppServer/wails-build-action@main
        env:
          # Pass ldflags via GOFLAGS environment variable - all -X flags in one -ldflags
          GOFLAGS: "-ldflags=-X=github.com/tassa-yoniso-manasi-karoto/langkit/internal/version.Version=${{ steps.version.outputs.VERSION }} -X=github.com/tassa-yoniso-manasi-karoto/langkit/internal/version.Commit=${{ steps.version.outputs.COMMIT }} -X=github.com/tassa-yoniso-manasi-karoto/langkit/internal/version.Branch=${{ steps.version.outputs.BRANCH }}"
        with:
          build-name: ${{ matrix.build.name }}
          build-platform: ${{ matrix.build.platform }}
          wails-version: ${{ env.WAILS_VERSION }}
          go-version: ${{ env.GO_VERSION }}
          node-version: ${{ env.NODE_VERSION }}
          sign: false
          package: false  # We'll handle packaging ourselves
          app-working-directory: "."
          # Let the action handle webkit2_41 tag automatically
          
      # Debug: Check what was actually built
      - name: Debug - Check build output
        shell: bash
        run: |
          echo "=== Looking for build output ==="
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la
          echo ""
          echo "=== Searching for executables ==="
          find . -name "*.exe" -o -name "*.app" -o -name "langkit*" -type f | grep -v node_modules | grep -v ".git" | head -20
          echo ""
          if [ -d "build" ]; then
            echo "=== Build directory structure ==="
            ls -la build/
            if [ -d "build/bin" ]; then
              echo "build/bin contents:"
              ls -la build/bin/
            fi
            if [ -d "build/windows" ]; then
              echo "build/windows contents:"
              ls -la build/windows/
            fi
          fi
          
      # Package both CLI and GUI together
      - name: Package distribution
        shell: bash
        run: |
          set -e  # Exit on error
          
          mkdir -p dist
          
          # Copy CLI
          if ls langkit-cli* 1> /dev/null 2>&1; then
            cp langkit-cli* dist/
          else
            echo "Warning: CLI binary not found"
          fi
          
          # Copy GUI based on platform
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            # Check multiple possible locations for Windows executable
            if ls langkit.exe 1> /dev/null 2>&1; then
              cp langkit.exe dist/
            elif ls build/bin/langkit.exe 1> /dev/null 2>&1; then
              cp build/bin/langkit.exe dist/
            elif ls build/bin/langkit 1> /dev/null 2>&1; then
              # Found Windows executable without .exe extension - this is suspicious
              echo "WARNING: Found Windows executable without .exe extension at build/bin/langkit"
              echo "This suggests GOOS/GOARCH were not properly set during build"
              cp build/bin/langkit dist/langkit.exe
            elif ls build/windows/*.exe 1> /dev/null 2>&1; then
              cp build/windows/*.exe dist/
            else
              echo "Error: Windows executable not found"
              echo "Searched: ./langkit.exe, build/bin/langkit.exe, build/bin/langkit, build/windows/*.exe"
              exit 1
            fi
            # Copy installer if it exists (check both locations)
            if ls build/windows/*-installer.exe 1> /dev/null 2>&1; then
              cp build/windows/*-installer.exe dist/
            elif ls build/bin/*-installer.exe 1> /dev/null 2>&1; then
              cp build/bin/*-installer.exe dist/
            fi
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            # Copy app bundle
            if ls build/bin/*.app 1> /dev/null 2>&1; then
              cp -r build/bin/*.app dist/
            else
              echo "Error: macOS app bundle not found"
              exit 1
            fi
            # Copy pkg installer if it exists
            if ls build/bin/*.pkg 1> /dev/null 2>&1; then
              cp build/bin/*.pkg dist/
            fi
            # Copy app.zip if it exists
            if ls build/bin/*.app.zip 1> /dev/null 2>&1; then
              cp build/bin/*.app.zip dist/
            fi
          else
            # Linux - copy all executables
            if ls build/bin/* 1> /dev/null 2>&1; then
              cp -r build/bin/* dist/
            else
              echo "Error: Linux binaries not found"
              exit 1
            fi
          fi
          
          # Determine version name for README
          VERSION_NAME=""
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            VERSION_NAME="${{ github.ref_name }}"
          else
            # Use branch name + short SHA for dev builds
            BRANCH_NAME="${{ github.ref_name }}"
            SHORT_SHA="${{ github.sha }}"
            SHORT_SHA="${SHORT_SHA:0:7}"
            VERSION_NAME="dev-${BRANCH_NAME}-${SHORT_SHA}"
          fi
          
          # Create a README for the distribution
          cat > dist/README.txt << EOF
          # langkit ${VERSION_NAME}
          
          ## Requirements:
          - FFmpeg v6 or higher (dev builds preferred)
          - MediaInfo
          - Replicate API token (for some features)
          
          ## Usage:
          CLI: Run langkit-cli (or langkit-cli.exe on Windows)
          GUI: Run langkit (or langkit.exe on Windows)
          
          ## Platform: ${{ matrix.build.platform }}
          Build date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          EOF
          
      # Upload artifacts
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: langkit-${{ matrix.build.platform_sanitized }}-${{ github.sha }}
          path: dist/*
          
  # Create release if this is a tag
  release:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: langkit-*
          
      - name: Organize release files
        run: |
          # Create directories for each platform
          mkdir -p release-files
          
          # Move all downloaded files to release-files, preserving platform organization
          for dir in langkit-*/; do
            if [ -d "$dir" ]; then
              platform=$(basename "$dir" | sed 's/-[^-]*$//')
              cp -r "$dir"* release-files/
            fi
          done
          
          # List what we have for debugging
          echo "Release files:"
          ls -la release-files/
          
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          files: release-files/*
          draft: false
          prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}
          generate_release_notes: true
          body: |
            ## Installation
            
            1. Download the appropriate files for your platform
            2. Ensure you have the required runtime dependencies:
               - FFmpeg v6+ (dev builds recommended)
               - MediaInfo
               - Replicate API token (for voice enhancement and STT features)
            
            ## What's included
            
            - `langkit-cli` - Command line interface
            - `langkit` - GUI application
            - Platform-specific installers (where applicable)
            
            ## Platforms
            
            - **Linux (amd64)**: Download files ending in `-linux-amd64`
            - **Windows (amd64)**: Download files ending in `-windows-amd64`
            - **macOS (universal)**: Download files ending in `-darwin-universal` (Intel + Apple Silicon)
            
            See the [README](https://github.com/tassa-yoniso-manasi-karoto/langkit#readme) for detailed usage instructions.